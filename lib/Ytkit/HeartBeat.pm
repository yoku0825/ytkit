package Ytkit::HeartBeat;

########################################################################
# Copyright (C) 2025  yoku0825
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
########################################################################

use strict;
use warnings;
use utf8;
use base "Ytkit";

use Ytkit::IO;
use Ytkit::MySQLServer;

use Time::HiRes;
use Time::Piece;

use constant DELETE_ROW_LIMIT_GUIDE => 3000;

my $synopsis= q{  $ yt-heartbeat --host=mysql_host --port=mysql_port } .
              q{--user=mysql_account --password=mysql_password --interval=1};
my $script= sprintf("%s - Write heartbeat record into MySQL", $0);
my $description= << 'EOS';
yt-heartbeat writes heartbeat record into Replication-Source like below.

CREATE TABLE heartbeat (
  hostname VARCHAR(255) NOT NULL,
  app_time DATETIME(3) NOT NULL,
  server_time DATETIME(3) NOT NULL PRIMARY KEY,
  gtid_executed TEXT NOT NULL
);

INSERT INTO heartbeat SET
  hostname = @@hostname,
  app_time = ?, -- generated by this script.
  server_time = NOW(3),
  gtid_executed = @@global.gtid_executed;
EOS

my $allow_extra_argv= 0;


sub new
{
  my ($class, @orig_argv)= @_;
  my $config= _config();
  $config->parse_argv(@orig_argv);

  my $self= { _config => $config,
              %{$config->{result}},
            };
  bless $self => $class;
  $self->handle_help;

  return $self;
}

sub init
{
  my ($self)= @_;

  $self->check_read_only;

  if ($self->{disable_sql_log_bin})
  {
    $self->instance->exec_sql("SET SESSION sql_log_bin = OFF");
  }

  $self->instance->exec_sql_with_croak(sprintf(q|CREATE DATABASE IF NOT EXISTS `%s`|, $self->{schema}));
  my $create_sql= << 'EOS';
CREATE TABLE IF NOT EXISTS `%s`.`%s` (
  hostname VARCHAR(255) NOT NULL,
  app_time DATETIME%s NOT NULL,
  server_time DATETIME%s NOT NULL PRIMARY KEY,
  gtid_executed TEXT NOT NULL
)
EOS
  $self->instance->exec_sql_with_croak(sprintf($create_sql,
                                               $self->{schema}, $self->{table},
                                               $self->instance->mysqld_version lt 50600 ? "" : "(3)",
                                               $self->instance->mysqld_version lt 50600 ? "" : "(3)"));
  $self->instance->exec_sql_with_croak(sprintf(q|TRUNCATE `%s`.`%s`|, $self->{schema}, $self->{table})) if $self->{truncate};
  return 0;
}

sub run
{
  my ($self)= @_;

  if ($self->instance->valueof("binlog_format") eq "STATEMENT")
  {
    _croakf(q|binlog_format = STATEMENT detected. %s using @@hostname, binlog_format = STATEMENT leads data inconsistency. Aborted.|, $0);
  }

  $SIG{ALRM}= sub { $self->instance->reconnect };
  alarm($self->{timeout});
  my $insert_sql;

  if ($self->instance->mysqld_version lt 50600)
  {
    ### 5.5 and earlier doesn't have gtid_executed and fractional second
    $insert_sql= sprintf(q|INSERT INTO `%s`.`%s` (hostname, app_time, server_time, gtid_executed) VALUES (@@hostname, ?, NOW(), '')|,
                         $self->{schema}, $self->{table});
  }
  else
  {
    $insert_sql= sprintf(q|INSERT INTO `%s`.`%s` (hostname, app_time, server_time, gtid_executed) VALUES (@@hostname, ?, NOW(3), @@global.gtid_executed)|,
                         $self->{schema}, $self->{table});
  }
  my $delete_sql= sprintf("DELETE FROM `%s`.`%s` WHERE server_time < NOW() - INTERVAL %d DAY",
                          $self->{schema}, $self->{table}, $self->{retention_period});

  my $count= 0;
  while ()
  {
    $count++;

    ### read_only could be changed during heartbeating
    $self->check_read_only;

    ### To avoid reset variable by reconnection, execute this statement every time.
    if ($self->{disable_sql_log_bin})
    {
      $self->instance->exec_sql("SET SESSION sql_log_bin = OFF");
    }

    my ($unixtime, $microsec)= Time::HiRes::gettimeofday();
    my $now= sprintf("%s.%3d", Time::Piece->strptime($unixtime, "%s")->strftime("%Y-%m-%d %H:%M:%S"), $microsec);

    $self->instance->exec_sql_with_carp($insert_sql, undef, $now);

    if ($self->instance->error)
    {
      _notef("HeartBeat Failed at %s : %s", $now, $self->instance->error);
      $self->instance->reconnect;
    }
    else
    {
      _infof("HeartBeat Succeeded at %s\n", $now);
    }

    if ($count ge DELETE_ROW_LIMIT_GUIDE)
    {
      _infof("Remove old heartbeat records, %d days ago", $self->{retention_period});
      $self->instance->exec_sql_with_carp($delete_sql);
      $count= 0;
    }

    sleep $self->{interval};
  }
}

sub check_read_only
{
  my ($self) = @_;

  $self->instance->conn;
  $self->instance->clear_cache;

  if ($self->instance->valueof("read_only") eq "ON")
  {
    if ($self->{force})
    {
      _carpf("Server %s is read_only = ON, but write forcefully because of --force", $self->instance->valueof("hostname"));
    }
    else
    {
      _croakf("Server %s is read_only = ON, aborting", $self->instance->valueof("hostname"));
    }
    return 1;
  }
  return 0;
}

sub _config
{
  my $program_option=
  {
    interval       => { alias   => ["interval", "i", "sleep"],
                        default => 1,
                        text => "Sleep seconds during each heartbeat INSERT.", },
    schema => { alias => ["schema", "heartbeat-schema", "d"],
                default => "ytkit",
                text => "Where to create database for this script", },
    table => { alias => ["table", "heartbeat-table", "t"],
               default => "heartbeat",
               text => "Table name to store heartbeat records.", },
    truncate => { alias => ["truncate", "truncate-before-insert"],
                  default => 0,
                  noarg => 1,
                  text => "TRUNCATE TABLE under init process.", },
    force => { alias => ["force", "f"],
               default => 0,
               noarg => 1,
               text => "Write heartbeat records forcefully even if read_only = ON (need SUPER priv)", },
    disable_sql_log_bin => { alias => ["disable_sql_log_bin", "sql_log_bin_off", "disable_log_bin"],
                             text  => "Write heartbeat records without binary-log (need SUPER priv)",
                             noarg => 1,
                             default => 0, },
    retention_period => { alias => ["retention_period", "retention"],
                          default => 30,
                          isa => qr/\d+/,
                          text => "Remove records after --retention-period days", },
  };
  my $config= Ytkit::Config->new({ %$program_option, 
                                   %$Ytkit::Config::CONNECT_OPTION,
                                   %$Ytkit::Config::COMMON_OPTION });
  $config->{_synopsis}= $synopsis;
  $config->{_description}= $description;
  $config->{_script}= $script;
  $config->{_allow_extra_argv}= $allow_extra_argv;
  return $config;
}

return 1;
